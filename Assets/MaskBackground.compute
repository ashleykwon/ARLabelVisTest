// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
// #pragma kernel GetCIELAB

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<int4> backgroundScreenshotForSum;
Texture2D<int4> labelScreenshotForSum;
RWTexture2D<int4> Result;
int2 labelCenterCoord;
int granularityMethod;
float distanceThreshold;
int image_width;
int image_height;
// float4 averageBackgroundColor;
// int4 CIELABResult;
// int CandidateLABVals[408];
// int distanceToReturn;


float2 pixel_to_coord(int2 pixel, int image_width, int image_height){
    // Convert pixel position to spherical coordinates
    float lon = (pixel[0] / image_width) * 360 - 180;
    float lat = 90 - (pixel[1] / image_height) * 180;
    float2 result = float2(lon, lat);
    return result;
}

float great_circle_distance(int2 target_pixel, int2 source_pixel, int image_width, int image_height){
    // Assuming the image represents a full 360 degree view of the sphere
    // Convert pixel coordinates to longitude and latitude
    float2 lon1lat1 = pixel_to_coord(target_pixel, image_width, image_height);
    float lon1 = lon1lat1[0];
    float lat1 = lon1lat1[1];

    float2 lon2lat2 = pixel_to_coord(source_pixel, image_width, image_height);
    float lon2 = lon2lat2[0];
    float lat2 = lon2lat2[1];
    
    // Convert degrees to radians
    // lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])
    lon1 = radians(lon1);
    lat1 = radians(lat1);
    lon2 = radians(lon2);
    lat2 = radians(lat2);
    
    // Haversine formula
    float dlon = lon2 - lon1;
    float dlat = lat2 - lat1;
    float a = pow(sin(dlat/2), 2) + cos(lat1) * cos(lat2) * pow(sin(dlon/2), 2);
    float c = 2 * asin(sqrt(a));
    
    // Radius of the image in pixels (mean radius)
    float R = image_width/(2*radians(180));
    float distance = R * c;
    
    return distance;
}


[numthreads(1, 1 ,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{   
    if (granularityMethod == 1){
        if (labelScreenshotForSum[id.xy].x > 200 && labelScreenshotForSum[id.xy].y > 200 && labelScreenshotForSum[id.xy].z > 200){
            Result[id.xy] = backgroundScreenshotForSum[id.xy];
        }
        else{
            Result[id.xy] = int4(0, 0, 0, 0);
        }
    }

    else if (granularityMethod == 2){
        float distance = great_circle_distance(id.xy, labelCenterCoord, image_width, image_height);
        if (distance <= distanceThreshold){
            Result[id.xy] = backgroundScreenshotForSum[id.xy];
        }
        else{
            Result[id.xy] = int4(0, 0, 0, 0);
        }
    }
    
}




// float4 RGB2LAB(float4 RGB) // probably referenced from here:
// {
//     float R = RGB.r;
//     float G = RGB.g;
//     float B = RGB.b;

//     // reference values, D65/2°
//     float Xr = 95.047;  
//     float Yr = 100.0;
//     float Zr = 108.883;

//     float var_R = R; //(R / 255.0);
//     float var_G = G; //(G / 255.0);
//     float var_B = B; //(B / 255.0);

//     if (R > 0.04045) 
//         var_R = pow(((var_R + 0.055) / 1.055), 2.4);
//     else
//         var_R = var_R / 12.92;

//     if (var_G > 0.04045)
//         var_G = pow(((var_G + 0.055) / 1.055), 2.4);
//     else
//         var_G = var_G / 12.92;

//     if (var_B > 0.04045)
//         var_B = pow(((var_B + 0.055) / 1.055), 2.4);
//     else
//         var_B = var_B / 12.92;

//     var_R *= 100;
//     var_G *= 100;
//     var_B *= 100;

//     float X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;
//     float Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;
//     float Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;

//     // now convert from XYZ to LAB

//     float var_X = X / Xr;
//     float var_Y = Y / Yr;
//     float var_Z = Z / Zr;

//     if (var_X > 0.008856)
//         var_X = pow(var_X, 1/3.0);
//     else
//         var_X = (7.787 * var_X) + (16.0 / 116.0);

//     if (var_Y > 0.008856)
//         var_Y = pow(var_Y, 1/3.0);
//     else
//         var_Y = (7.787 * var_Y) + (16.0 / 116.0);

//     if (var_Z > 0.008856)
//         var_Z = pow(var_Z, 1/3.0);
//     else
//         var_Z = (7.787 * var_Z) + (16.0 / 116.0);


//     float l = (116.0 * var_Y) - 16;
//     float a = 500.0 * (var_X - var_Y);
//     float b = 200.0 * (var_Y - var_Z); // Not sure why this was originally LAB[3]

//     return float4(l, a, b, RGB.a);
// } 

// float4 LAB2RGB(float4 LAB)
// {
//     float L = LAB[0];
//     float A = LAB[1];
//     float B = LAB[2];

//     // reference values, D65/2°
//     float Xr = 95.047;  
//     float Yr = 100.0;
//     float Zr = 108.883;

//     // first convert LAB to XYZ
//     float var_Y = (L + 16.0) / 116.0;
//     float var_X = A / 500 + var_Y;
//     float var_Z = var_Y - B / 200.0;

//     if (pow(var_Y, 3)  > 0.008856) 
//         var_Y = pow(var_Y, 3.0);
//     else
//         var_Y = (var_Y - 16 / 116) / 7.787;
//     if (pow(var_X, 3)  > 0.008856)
//         var_X = pow(var_X, 3.0);
//     else
//         var_X = (var_X - 16 / 116) / 7.787;
//     if (pow(var_Z, 3)  > 0.008856) 
//         var_Z = pow(var_Z, 3.0);
//     else
//         var_Z = (var_Z - 16.0 / 116.0) / 7.787;

//     float X = var_X * Xr;
//     float Y = var_Y * Yr;
//     float Z = var_Z * Zr;

//     // now convert XYZ to RGB
//     X /= 100.0;
//     Y /= 100.0;
//     Z /= 100.0;

//     float var_R = var_X *  3.2406 + var_Y * -1.5372 + var_Z * -0.4986;
//     float var_G = var_X * -0.9689 + var_Y *  1.8758 + var_Z *  0.0415;
//     float var_B = var_X *  0.0557 + var_Y * -0.2040 + var_Z *  1.0570;

//     if (var_R > 0.0031308) 
//         var_R = 1.055 * (pow(var_R, (1 / 2.4))) - 0.055;
//     else
//         var_R = 12.92 * var_R;
//     if (var_G > 0.0031308) 
//         var_G = 1.055 * (pow(var_G, (1 / 2.4))) - 0.055;
//     else
//         var_G = 12.92 * var_G;
//     if (var_B > 0.0031308) 
//         var_B = 1.055 * (pow(var_B, (1 / 2.4))) - 0.055;
//     else
//         var_B = 12.92 * var_B;

//     // ensure values are between 0 and 1
//     var_R = max(min(var_R, 1), 0);
//     var_G = max(min(var_G, 1), 0);
//     var_B = max(min(var_B, 1), 0);
//     return float4(var_R, var_G, var_B, LAB.a);
// }

// float CIEDE00(float4 LAB1, float4 LAB2){ // from https://hajim.rochester.edu/ece/sites/gsharma/ciede2000/ciede2000noteCRNA.pdf
//     float distance = 0.0;
    
//     // Get the LAB values from the inputs
//     float L1 = LAB1[0];
//     float a1 = LAB1[1];
//     float b1 = LAB1[2];

//     float L2 = LAB2[0];
//     float a2 = LAB2[1];
//     float b2 = LAB2[2];

//     float L_avg = (L1 + L2)/2;

//     // Calculate C and h
//     float C_Lab1 = sqrt(pow(a1, 2) + pow(b1, 2));
//     float C_Lab2 = sqrt(pow(a2, 2) + pow(b2, 2));
//     float C_avg = (C_Lab1 + C_Lab2)/2;

//     float G = 0.5*(1 - sqrt(pow(C_avg, 7)/(pow(C_avg, 7) + pow(25, 7))));
//     float a1_prime = (1 + G)*a1;
//     float a2_prime = (1 + G)*a2;
    
//     float h_Lab1 = 0;
//     float h_Lab2 = 0;
//     if (a1_prime != 0 && b1 != 0){
//         h_Lab1 = atan(b1/a1_prime);
//     }
//     if (a2_prime != 0 && b2 != 0){
//         h_Lab2 = atan(b1/a2_prime);
//     }

//     float h_avg = 0;
//     if (abs(h_Lab1 - h_Lab2) <= 180 && C_Lab1*C_Lab2 != 0){
//         h_avg = (h_Lab1 + h_Lab2)/2;
//     }
//     else if (abs(h_Lab1 - h_Lab2) > 180 && (h_Lab1 + h_Lab2) < 360 && C_Lab1*C_Lab2 != 0){
//         h_avg = (h_Lab1 + h_Lab2 + 360)/2;
//     }
//     else if (abs(h_Lab1 - h_Lab2) > 180 && (h_Lab1 + h_Lab2) >= 360 && C_Lab1*C_Lab2 != 0){
//         h_avg = (h_Lab1 + h_Lab2 - 360)/2;
//     }
//     else if (C_Lab1*C_Lab2 == 0){
//         h_avg = h_Lab1 + h_Lab2;
//     }
    
//     // Calculate deltaL, deltaC, deltaH
//     float deltaL = L2 - L1;
//     float deltaC = C_Lab2 - C_Lab1;
//     float deltaH = 0;
//     if (C_Lab1*C_Lab2 == 0){
//         deltaH = 0;
//     }
//     else if (C_Lab1*C_Lab2 != 0 && abs(h_Lab2 - h_Lab1) <= 180){
//         deltaH = h_Lab2 - h_Lab1;
//     }
//     else if (C_Lab1*C_Lab2 != 0 && (h_Lab2 - h_Lab1) > 180){
//         deltaH = h_Lab2 - h_Lab1 - 360;
//     }
//     else if (C_Lab1*C_Lab2 != 0 && (h_Lab2 - h_Lab1) < -180){
//         deltaH = h_Lab2 - h_Lab1 + 360;
//     }

//     // Calculate T S_l, S_c, S_h, and R_t
//     float T = 1 - 0.17*cos(h_avg - 30) + 0.24*cos(2*h_avg) + 0.32*cos(3*h_avg + 6) - 0.2*cos(4*h_avg - 63);
//     float deltaTheta = 30*exp(-1*pow((h_avg - 275)/25, 2));
//     float R_c = 2*sqrt(pow(C_avg, 7)/(pow(C_avg, 7) + pow(25, 7)));
//     float S_l = 1 + ((0.015*pow(L_avg - 50, 2))/sqrt(20 + pow(L_avg - 50, 2)));
//     float S_c = 1 + 0.045*C_avg;
//     float S_h = 1 + 0.015*C_avg*T;
//     float R_t = -sin(2*deltaTheta*R_c);

//     // Calculate CIEDE00 (assume k_l = k_c = k_h = 0)
//     distance = sqrt(pow(deltaL/S_l, 2) + pow(deltaC/S_c, 2) + pow(deltaH/S_h, 2) + R_t*(deltaC/S_c)*(deltaH/S_h));

//     return distance;
// }


// [numthreads(1, 1, 1)]
// void GetCIELAB (uint3 id : SV_DispatchThreadID)
// {   
//     float maxDiatance = 0;
//     float4 LABatMaxDistance = float4(0, 0, 0, 1);
//     float4 backgroundLAB = float4(0, 0, 0, 0);
//     if (granularityMethod == 0){ // per pixel
//         backgroundLAB = RGB2LAB(float4(backgroundScreenshotForSum[id.xy].x/255.0, backgroundScreenshotForSum[id.xy].y/255.0, backgroundScreenshotForSum[id.xy].z/255.0, 1));
//     }
//     else{ // per-area or per-background (one average value)
//         backgroundLAB = float4(averageBackgroundColor[0], averageBackgroundColor[1], averageBackgroundColor[2], 1);
//     }

//     for (int i = 0; i <= 406; i+=3){
//         float distance = CIEDE00(backgroundLAB, float4(float(CandidateLABVals[i]), float(CandidateLABVals[i+1]), float(CandidateLABVals[i+2]), 1.0));
//         if (distance > maxDiatance){
//             maxDiatance = distance;
//             LABatMaxDistance = float4(float(CandidateLABVals[i]), float(CandidateLABVals[i+1]), float(CandidateLABVals[i+2]), 1.0);
//         }
//     }
    
//     float4 LabelRGBVal = LAB2RGB(LABatMaxDistance);
//     distanceToReturn = maxDiatance;
//     // Set label color absed on calculation result
//     if (labelScreenshotForSum[id.xy].x > 200 && labelScreenshotForSum[id.xy].y > 200 && labelScreenshotForSum[id.xy].z > 200){
//         Result[id.xy] = int4(255, 0, 0, 255);
//         // int4(int(LabelRGBVal[0]*255), int(LabelRGBVal[1]*255), int(LabelRGBVal[2]*255), 255);
//     }
//     else{
//         Result[id.xy] = int4(0, 0, 0, 0);
//     }
//     // if (granularityMethod == 0){
//     //     Result[id.xy] = int4(int(LabelRGBVal[0]*255), int(LabelRGBVal[1]*255), int(LabelRGBVal[2]*255), 255); // TODO: adjust the alpha level based on mode settings
//     // }
//     // else{
//     //     CIELABResult = int4(int(LabelRGBVal[0]*255), int(LabelRGBVal[1]*255), int(LabelRGBVal[2]*255), 255); 
//     // }
    
// }

